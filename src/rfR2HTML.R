source(file.path(REGO_HOME, "/src/rfExport.R"))
source(file.path(REGO_HOME, "/src/rfRulesIO.R"))
library(R2HTML)
library(ROCR, verbose = FALSE, quietly=TRUE, warn.conflicts = FALSE)

WriteHTML <- function(conf, model.path, out.path = model.path, rfmod.stats = NULL)
{
  # Writes an HTML page with information about a RuleFit model. Page includes
  # variable importance table, rules, training confusion matrix, training ROC
  # curve, etc.
  #
  # Args:
  #     model.path : rulefit model location (content generated by
  #                  ExportModel() function)
  #           conf : html configuration parameters
  #       out.path : String naming the location to write to (default
  #                  is model.path/R2HTML)
  #    rfmod.stats : fit statistics of a rulefit model
  #
  # Returns:
  #     None.
  kPlotWidth <- 620
  kPlotHeight <- 480
  
  if (out.path == model.path) {
    out.path <- file.path(out.path, "R2HTML")
  }
  # Create output directory (if appropriate)
  if (!file.exists(out.path)) {
    dir.create(out.path)
  }

  # Initialize HTML report
  html.file <- HTMLInitFile(out.path, conf$html.fname, Title = conf$html.title,
                            BackGroundColor = "#BBBBEE")
  HTML.title(conf$html.title)

  # Read variable importance table
  vi.df <- read.table(file.path(model.path, kMod.varimp.fname), header = F, sep = "\t")
  colnames(vi.df) <- c("Importance", "Variable")
  # ... filter out low importance entries
  i.zero.imp <- which(vi.df$Importance < conf$html.min.var.imp)
  if ( length(i.zero.imp == 1) ) {
    vi.df <- vi.df[-i.zero.imp, ]
  }
  # ... Format float values for easier reading
  vi.df$Importance <- sprintf("%.1f", vi.df$Importance)  

  # Write out var imp
  HTML(vi.df, caption = "Global Variable Importance", row.names = F)

  # Read model rules
  rules <- ReadRules(file.path(model.path, kMod.rules.fname))
  rules.df <- PrintRules(rules, x.levels.fname = file.path(model.path, kMod.x.levels.fname), file = NULL)
  if (!setequal(colnames(rules.df), c("type", "supp.std", "coeff", "importance", "def"))) {
    error(logger, "WriteHTML: Rules header mismatch")
  }
  # ... filter out low importance entries
  i.zero.imp <- which(rules.df$importance < conf$html.min.rule.imp)
  if ( length(i.zero.imp == 1) ) {
    rules.df <- rules.df[-i.zero.imp, ]
  }
  # ... Rename column to more verbose values
  colnames(rules.df) <- c("Rule", "Support (or std)", "Coefficient", "Importance", "Definition")
  rules.df$Rule <- 1:nrow(rules.df)
  # ... Replace 'AND' with '&' in rule strings for easier reading
  rules.df$Definition <- gsub(" AND ", " & ", rules.df$Definition)
  # ... Format float values for easier reading
  rules.df$Importance <- sprintf("%.1f", rules.df$Importance)
  rules.df$Coefficient <- sprintf("%.3f", rules.df$Coefficient)

  # Write out rules
  HTML(rules.df, caption = "Rule Ensemble Model", row.names = F, innerBorder = 1)
  
  # Read (train) y and yHat
  y <- LoadModel(model.path)$y
  saved.y.hat <- load(file = file.path(model.path, kMod.yHat.fname))
  if ( length(which((saved.y.hat == c("y.hat")) == T)) != 1 ) {
    stop("Failed to find required objects in: ", file.path(model.path, kMod.yHat.fname))
  }

  # Process y vs yHat according to model type
  if (length(unique(y)) == 2) {
    # "classification" mode... build confusion table
    conf.m <- table(y, sign(y.hat))
    stopifnot("-1" %in% rownames(conf.m))
    stopifnot("1" %in% rownames(conf.m))
    TN <- ifelse("-1" %in% colnames(conf.m), conf.m["-1", "-1"], 0)
    TP <- ifelse("1" %in% colnames(conf.m), conf.m["1","1"], 0)
    train.acc <- 100*(TN+TP)/sum(conf.m)
    # Write out table
    HTML(conf.m, caption = sprintf("Training Confusion Matrix (accuracy: %.2f%%)", train.acc),
         innerBorder = 1)
    # Generate ROC plot
    pred <- prediction(y.hat, y)
    perf <- performance(pred, "tpr", "fpr")
    plot.fname <- "ROC.png"
    png(file = file.path(out.path, plot.fname), width=kPlotWidth, height=kPlotHeight)
    plot(perf, colorize=T, main="")
    lines(x=c(0, 1), y=c(0,1))
    dev.off()
    HTMLInsertGraph(plot.fname, Caption="Training ROC curve", WidthHTML=kPlotWidth, HeightHTML=kPlotHeight)
  } else {
    # "regression" mode... create data-frame with simple AAE meassure
    re.train.error <- sum(abs(y.hat - y))/length(y)
    med.train.error <- sum(abs(y - median(y)))/length(y)
    aae.train <- re.train.error / med.train.error
    error.df <- data.frame(cbind(c("RE", "Median  ", "ratio"),
                                c(round(re.train.error, 4), round(med.train.error, 4), round(aae.train, 2))))
    colnames(error.df) <- c("Model", "Error")                   
    HTML(error.df, caption = "Training Error (Unweighted)", row.names = F, col.names = F)
  }

  # Write out (estimated) test error 
  error.df <- data.frame(cbind(c("RE"), c(round(rfmod.stats$cri, 4)), c(round(rfmod.stats$err))))
  colnames(error.df) <- c("Model", "Error", "+/-")                   
  HTML(error.df, caption = "Test Error (estimated)", row.names = F, col.names = F)
  
  # End report
  HTMLEndFile()
}

WriteHTMLSinglePlot <- function(conf, model.path, vars = NULL, out.path = model.path, 
                                do.restore = FALSE, xmiss = 9.0e30)
{
  # Writes an HTML page with single variable partial dependence plots for a given
  # RuleFit model. 
  #
  # Args:
  #           conf : html configuration parameters
  #     model.path : rulefit model location (content generated by
  #                  ExportModel() function)
  #           vars : vector of variable identifiers (column names) 
  #                  specifying selected variables to be plotted. If NULL,
  #                  variable names are taken from varimp table.
  #       out.path : String naming the location to write to (default
  #                  is model.path/R2HTML/singleplot
  #     do.restore : whether or not a model restore is needed -- e.g, not 
  #                  necessary if called inmediatedly after a model build. 
  # Returns:
  #     None.
  AddQuantileJitter <- function(q)
  {
    # Add a small amount of noise to given numeric vector, assumed to represent 
    # quantiles of a variable, when adjacent values are equal. 
    set.seed(123)
    q.rle <- rle(q)
    out.q <- c()
    for (i in seq(along=q.rle$lengths)) {
      num.eq <- q.rle$lengths[i]
      if (num.eq > 1) {
        tmp.q <- rep(q.rle$values[i], num.eq)
        if ( q.rle$values[i] > 1) { 
          tmp.q <- sort(jitter(tmp.q, factor = 0.75))
        } else {
          # small value... do jittering by hand
          i.mid <- ceiling(num.eq/2)
          jitter.amount <- 0.005 * (1:num.eq - i.mid)
          tmp.q <- tmp.q + jitter.amount
        }
      } else {
        tmp.q <- c(q.rle$values[i])
      }
      out.q <- c(out.q, tmp.q)
    }
    return(out.q)
  }
   
  GetRugQuantiles <- function(x, var, xmiss, do.jitter = TRUE)
  {
    # Computes quantiles for generating a "rug" (skips NA in calculation).
    # Args:
    #           x : "matrix" -- e.g., from model restore
    #         var : column name in x for whcih quantiles are to be computed
    #       xmiss : NA value
    #   do.jitter : whether or not "jitter" should be added to differentiate
    #               equal quantile values
    # Returns:
    #     list(quant:quantile values, na.rate: number of NAs as percentage 
    quant <- NULL
    na.rate <- NULL
    i.col <- grep(paste("^", var, "$", sep = ""), colnames(x), perl=T)
    if ( length(i.col) > 0 ) {
      which.NA <- which(x[,i.col] == xmiss)
      na.rate <- round(100*length(which.NA)/nrow(x), 1)
      if (length(which.NA) < nrow(x)) {
        quant <- quantile(x[, i.col], na.rm = T, probs = seq(0.1, 0.9, 0.1))
        if (do.jitter) {
          quant <- AddQuantileJitter(quant)
        }
      }
    }
    return(list(quant = quant, na.rate = na.rate))
  }
  
  if (out.path == model.path) {
    out.path <- file.path(out.path, "R2HTML", "singleplot")
  }
  # Create output directory (if appropriate)
  if (!file.exists(out.path)) {
    dir.create(out.path)
  }
  
  # Load & restore model
  mod <- LoadModel(model.path)
  ok <- 1
  if (do.restore) {
    tryCatch(rfrestore(mod$rfmod, mod$x, mod$y, mod$wt), error = function(err){ok <<- 0})
    if (ok == 0) {
      error(logger, "WriteHTMLSinglePlot: got stuck in rfrestore")
    } 
  }

  # Load levels 
  x.levels <- as.data.frame(do.call("rbind", ReadLevels(file.path(model.path, kMod.x.levels.fname))))
  if (ncol(x.levels) != 2 || any(colnames(x.levels) != c("var", "levels"))) {
    error(logger, "WriteHTMLSinglePlot: problem reading level info")
  } else {
    var.names <- x.levels[, 1]
    x.levels <- x.levels[, 2]
    names(x.levels) <- var.names
  }

  # Initialize HTML report
  html.file <- HTMLInitFile(out.path, conf$html.singleplot.fname, Title = conf$html.title,
      BackGroundColor = "#BBBBEE")
  HTML.title(conf$html.singleplot.title)
  
  # Which variables are to be plotted?
  # ... read variable importance table
  vi.df <- read.table(file.path(model.path, kMod.varimp.fname), header = F, sep = "\t")
  colnames(vi.df) <- c("Importance", "Variable")
  if (is.null(vars)) {
    # ... pick subset from varimp list
    # ... ... first, filter out low importance entries
    min.var.imp <- max(conf$html.min.var.imp, 1.0) 
    i.zero.imp <- which(vi.df$Importance < min.var.imp)
    if ( length(i.zero.imp == 1) ) {
      vi.df <- vi.df[-i.zero.imp, ]
    }
    nvars <- min(conf$html.singleplot.nvars, nrow(vi.df))
    vars <- vi.df$Variable[1:nvars]
  } else {
    nvars <- length(vars)
    if (length(intersect(vars, vi.df$Variable)) != nvars) {
      error(logger, "WriteHTMLSinglePlot: variable name mismatch")
    }
  }
  
  # Generate plots
  for (var in vars) {
    plot.fname <- paste(var, "png", sep = ".")
    plot.width <- 620
    plot.height <- 480
    cat.vals <- NULL
    rug.vals <- NULL
    rug.cols <- NULL
    # Get levels, if this is a categorical variables. Get deciles, if continuous.
    if (!is.null(x.levels[var][[1]])) {
      cat.vals <- sapply(x.levels[var][[1]], substr, 1, 10, USE.NAMES = F)
      if (length(cat.vals) > 40 ) {
        plot.width <- 920
      }
      plot.caption <- var
    } else {     
      rug.out <- GetRugQuantiles(mod$x, var, xmiss)
      rug.vals <- rug.out$quant
      if (!is.null(rug.vals)) {
        rug.cols <- rainbow(length(rug.vals))
      }
      # Insert NA rate in caption
      plot.caption <- paste(var, " (NAs: ", rug.out$na.rate, "%)", sep="")
    }
    png(file = file.path(out.path, plot.fname), width=plot.width, height=plot.height)
    # tryCatch(singleplot(var, catvals=cat.vals, rugvals=rug.vals, rugcols=rug.cols), 
    #          error = function(err){ok <<- 0})
    tryCatch(singleplot(var, catvals=cat.vals), error = function(err){ok <<- 0})
    if (ok == 0) {
      error(logger, "WriteHTMLSinglePlot: got stuck in singleplot")
    }
    dev.off()
    HTMLInsertGraph(plot.fname, Caption=plot.caption, WidthHTML=plot.width, HeightHTML=plot.height)
  } 
  
  # End report
  HTMLEndFile()
}
